// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_LPTC_CODERDOJO_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_LPTC_CODERDOJO_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace lptc_coderdojo {
namespace protocol {

struct DeviceData;

struct Message;

enum class MessageType : uint8_t {
  Error = 0,
  DeviceData = 1,
  MIN = Error,
  MAX = DeviceData
};

inline const MessageType (&EnumValuesMessageType())[2] {
  static const MessageType values[] = {
    MessageType::Error,
    MessageType::DeviceData
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[] = {
    "Error",
    "DeviceData",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (e < MessageType::Error || e > MessageType::DeviceData) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

enum class DataType : uint8_t {
  Depth = 0,
  Video = 1,
  MIN = Depth,
  MAX = Video
};

inline const DataType (&EnumValuesDataType())[2] {
  static const DataType values[] = {
    DataType::Depth,
    DataType::Video
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[] = {
    "Depth",
    "Video",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (e < DataType::Depth || e > DataType::Video) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesDataType()[index];
}

struct DeviceData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DEPTH = 6,
    VT_VIDEO = 8
  };
  DataType type() const {
    return static_cast<DataType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *depth() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DEPTH);
  }
  const flatbuffers::Vector<uint8_t> *video() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VIDEO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_DEPTH) &&
           verifier.VerifyVector(depth()) &&
           VerifyOffset(verifier, VT_VIDEO) &&
           verifier.VerifyVector(video()) &&
           verifier.EndTable();
  }
};

struct DeviceDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(DataType type) {
    fbb_.AddElement<uint8_t>(DeviceData::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_depth(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> depth) {
    fbb_.AddOffset(DeviceData::VT_DEPTH, depth);
  }
  void add_video(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> video) {
    fbb_.AddOffset(DeviceData::VT_VIDEO, video);
  }
  explicit DeviceDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceDataBuilder &operator=(const DeviceDataBuilder &);
  flatbuffers::Offset<DeviceData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeviceData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeviceData> CreateDeviceData(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType type = DataType::Depth,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> depth = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> video = 0) {
  DeviceDataBuilder builder_(_fbb);
  builder_.add_video(video);
  builder_.add_depth(depth);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeviceData> CreateDeviceDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType type = DataType::Depth,
    const std::vector<uint8_t> *depth = nullptr,
    const std::vector<uint8_t> *video = nullptr) {
  auto depth__ = depth ? _fbb.CreateVector<uint8_t>(*depth) : 0;
  auto video__ = video ? _fbb.CreateVector<uint8_t>(*video) : 0;
  return lptc_coderdojo::protocol::CreateDeviceData(
      _fbb,
      type,
      depth__,
      video__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TYPE = 6,
    VT_ERROR = 8,
    VT_DATA = 10
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  MessageType type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const DeviceData *data() const {
    return GetPointer<const DeviceData *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Message::VT_TIMESTAMP, timestamp, 0);
  }
  void add_type(MessageType type) {
    fbb_.AddElement<uint8_t>(Message::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(Message::VT_ERROR, error);
  }
  void add_data(flatbuffers::Offset<DeviceData> data) {
    fbb_.AddOffset(Message::VT_DATA, data);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    MessageType type = MessageType::Error,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<DeviceData> data = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_data(data);
  builder_.add_error(error);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    MessageType type = MessageType::Error,
    const char *error = nullptr,
    flatbuffers::Offset<DeviceData> data = 0) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return lptc_coderdojo::protocol::CreateMessage(
      _fbb,
      timestamp,
      type,
      error__,
      data);
}

inline const lptc_coderdojo::protocol::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<lptc_coderdojo::protocol::Message>(buf);
}

inline const lptc_coderdojo::protocol::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<lptc_coderdojo::protocol::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<lptc_coderdojo::protocol::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<lptc_coderdojo::protocol::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lptc_coderdojo::protocol::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<lptc_coderdojo::protocol::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace protocol
}  // namespace lptc_coderdojo

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_LPTC_CODERDOJO_PROTOCOL_H_
